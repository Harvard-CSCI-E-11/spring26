"""
Global variables are configured in grader.py as:

from e11.e11core.ssh import E11Ssh
ssh = E11Ssh((host=ctx["public_ip"], username="ubuntu", port=22, pkey_pem=key_pem, timeout=10)
ssh.set_working_dir(ctx["labdir"])
(rc,stdout,stderr) = ssh.exec()
ssh.close()

or:
with E11Ssh((host=ctx["public_ip"], username="ubuntu", port=22, pkey_pem=key_pem, timeout=10) as ssh:
   ssh.exec()

and ssh.close is called automatically

This code generated by ChatGPT 5
"""

import shlex
import io
import paramiko

from .utils import get_logger

LOGGER = get_logger("e11core")

def _q(s: str) -> str:
    return shlex.quote(s)

class E11Ssh:
    def __init__(self, host, username="ubuntu", port=22, key_filename=None, pkey_pem=None, timeout=10): # pylint: disable=too-many-positional-arguments
        """Create one SSH/SFTP session for grader mode."""
        LOGGER.debug("configure host=%s username=%s port=%s key_filename=%s timeout=%s",host,username,port,key_filename,timeout)
        assert isinstance(host,str)
        self._ssh = paramiko.SSHClient()
        self._ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        pkey = None
        if pkey_pem:
            for keycls in (paramiko.RSAKey, paramiko.Ed25519Key, paramiko.ECDSAKey):
                try:
                    pkey = keycls.from_private_key(io.StringIO(pkey_pem))
                    LOGGER.debug("key found. pkey=%s keycls=%s",pkey,keycls)
                    break
                except Exception: # pylint: disable=broad-exception-caught
                    continue
        try:
            LOGGER.debug("Attempting SSH connect with key_filename=%s pkey=%s",key_filename,pkey)
            self._ssh.connect(hostname=host, port=port, username=username, key_filename=key_filename,
                         pkey=pkey, timeout=timeout, banner_timeout=timeout, auth_timeout=timeout)
            LOGGER.debug("connect successful")
        except OSError as e:
            LOGGER.error("OSError e=%s hostname=%s port=%s username=%s",e,host,port,username)
            raise
        self._sftp =None
        self._cwd = None


    def __enter__(self):
        return self

    def __exit__(self, ex_type, ex_value, ex_traceback):
        self.close()

    def set_working_dir(self, path: str):
        """Remote working dir used to resolve relative paths and 'cd' before commands."""
        self._cwd = path

    def exec(self, cmd: str, timeout=10):
        """Run a remote command (cd to _cwd first if set). Returns (rc, out, err)."""
        LOGGER.debug("cmd=%s",cmd)
        if self._ssh is None:
            raise RuntimeError("._ssh is None")
        if self._cwd:
            cmd = f"cd {_q(self._cwd)} && {cmd}"
        _, stdout, stderr = self._ssh.exec_command(cmd, timeout=timeout)
        rc = stdout.channel.recv_exit_status()
        out = stdout.read().decode("utf-8", "replace")
        err = stderr.read().decode("utf-8", "replace")
        return rc, out, err

    def sftp_read(self, path: str) -> bytes:
        """Read a remote file via SFTP (relative to _cwd if not absolute)."""
        if self._ssh is None:
            raise RuntimeError("._ssh is None")
        if self._sftp is None:
            self._sftp = self._ssh.open_sftp()
        rp = path if path.startswith("/") or not self._cwd else f"{self._cwd.rstrip('/')}/{path}"
        with self._sftp.open(rp, "r") as f:
            return f.read()

    def close(self):
        try:
            if self._sftp:
                self._sftp.close()
            if self._ssh:
                self._ssh.close()
        finally:
            self._ssh = None
            self._sftp = None
            self._cwd = None
