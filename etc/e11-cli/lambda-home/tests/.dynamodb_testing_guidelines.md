# DynamoDB Testing Guidelines

## ⚠️ CRITICAL: Use DynamoDB Local, NOT Mocking

**DO NOT mock DynamoDB table operations in tests.**

### ✅ CORRECT Approach

```python
def test_example(fake_aws, dynamodb_local):
    # Create actual records in DynamoDB Local
    test_email = "test@example.com"
    user = create_new_user(test_email, {"email": test_email, "name": "Test"})
    ses = new_session(event, {"email": test_email})

    # Query the real DynamoDB Local table
    user = get_user_from_email(test_email)
    sessions = all_sessions_for_email(test_email)
```

### ❌ WRONG Approach

```python
def test_example(fake_aws, dynamodb_local):
    # DON'T DO THIS - Don't mock DynamoDB operations
    users_table.query = MagicMock(return_value={"Items": [...]})
    sessions_table.query = MagicMock(return_value={"Items": [...]})
```

## Why?

1. **Real GSI Indexes**: DynamoDB Local tables have proper GSI indexes (GSI_Email) that need to be tested
2. **Real Query Behavior**: We need to test actual DynamoDB query behavior, not mocks
3. **Integration Testing**: Tests should verify the full stack works together

## When Mocking is Acceptable

The ONLY time it's acceptable to mock `users_table.query` is when you need to return empty items for logs/grades/images to simplify a test:

```python
# OK: Mocking to return empty logs/grades/images
home_module.users_table.query = MagicMock(return_value={"Items": [], "Count": 0})

# NEVER OK: Mocking session queries
sessions_table.query = MagicMock(...)  # DON'T DO THIS!
```

## Fixtures

- `dynamodb_local`: Provides access to DynamoDB Local (localhost:8000)
- `fake_aws`: Patches AWS services (Route53, SES, S3) but uses REAL DynamoDB Local tables
- `clean_dynamodb`: Cleans tables before/after each test if needed

## See Also

- `.cursorrules` - Cursor-specific instructions
- `tests/README.md` - General testing documentation
- `tests/conftest.py` - Fixture implementations
